<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
   <head>
      <title>Boost.Regex: class RegEx (deprecated)</title>
      <meta name="generator" content="HTML Tidy, see www.w3.org">
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
      <link rel="stylesheet" type="text/css" href="../../../boost.css">
   </head>
   <body>
      <p></p>
      <table id="Table1" cellspacing="1" cellpadding="1" width="100%" border="0">
         <tr>
            <td valign="top" width="300">
               <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
            </td>
            <td width="353">
               <h1 align="center">Boost.Regex</h1>
               <h2 align="center">class RegEx (deprecated)</h2>
            </td>
            <td width="50">
               <h3><a href="index.html"><img height="45" width="43" alt="Boost.Regex Index" src="uarrow.gif" border="0"></a></h3>
            </td>
         </tr>
      </table>
      <br>
      <br>
      <hr>
      <p>The high level wrapper class RegEx is now deprecated and does not form a part 
         of the <a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">regular 
            expression standardization proposal</a>.&nbsp; This type still exists, and 
         existing code will continue to compile, however the following documentation is 
         unlikely to be further updated.</p>
      <pre>
#include &lt;boost/cregex.hpp&gt;
</pre>
      <p>The class RegEx provides a high level simplified interface to the regular 
         expression library, this class only handles narrow character strings, and 
         regular expressions always follow the "normal" syntax - that is the same as the 
         perl / ECMAScript synatx.</p>
      <pre>
<b>typedef</b> <b>bool</b> (*GrepCallback)(<b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*GrepFileCallback)(<b>const</b> <b>char</b>* file, <b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*FindFilesCallback)(<b>const</b> <b>char</b>* file);

<b>class</b>  RegEx
{
<b>public</b>:
   RegEx();
   RegEx(<b>const</b> RegEx&amp; o);
   ~RegEx();
   RegEx(<b>const</b> <b>char</b>* c, <b>bool</b> icase = <b>false</b>);
   <strong>explicit</strong> RegEx(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
   RegEx&amp; <b>operator</b>=(<b>const</b> RegEx&amp; o);
   RegEx&amp; <b>operator</b>=(<b>const</b> <b>char</b>* p);
   RegEx&amp; <b>operator</b>=(<b>const</b> std::string&amp; s);
   <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> <b>char</b>* p, <b>bool</b> icase = <b>false</b>);
   <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
   std::string Expression()<b>const</b>;
   <font color="#000080"><i>//
</i>   <i>// now matching operators:</i> 
   <i>//</i></font> 
   <b>bool</b> Match(<b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default);
   <b>bool</b> Match(<b>const</b> std::string&amp; s, boost::match_flag_type flags = match_default); 
   <b>bool</b> Search(<b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default); 
   <b>bool</b> Search(<b>const</b> std::string&amp; s, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> std::string&amp; s, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> std::string&amp; s, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> std::string&amp; s, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, boost::match_flag_type flags = match_default); 
   std::string Merge(<b>const</b> std::string&amp; in, <b>const</b> std::string&amp; fmt, <b>bool</b> copy = <b>true</b>, boost::match_flag_type flags = match_default); 
   std::string Merge(<b>const</b> char* in, <b>const</b> char* fmt, <b>bool</b> copy = <b>true</b>, boost::match_flag_type flags = match_default); 
   <b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp; v, std::string&amp; s, boost::match_flag_type flags = match_default, <b>unsigned</b> max_count = ~0); 
   <font color="#000080"><i>// 
</i>   <i>// now operators for returning what matched in more detail: 
</i>   <i>// 
</i></font>   <b>unsigned</b> <b>int</b> Position(<b>int</b> i = 0)<b>const</b>; 
   <b>unsigned</b> <b>int</b> Length(<b>int</b> i = 0)<b>const</b>; 
   <strong>bool</strong> Matched(<strong>int</strong> i = 0)<strong>const</strong>;
   <b>unsigned</b> <b>int</b> Line()<b>const</b>; 
   <b>unsigned int</b> Marks() const; 
   std::string What(<b>int</b> i)<b>const</b>; 
   std::string <b>operator</b>[](<b>int</b> i)<b>const</b> ; 

   <strong>static const unsigned int</strong> npos;
};    
</pre>
      <p>Member functions for class RegEx are defined as follows:<br>
         &nbsp;</p>
      <p></p>
      <table id="Table2" cellspacing="0" cellpadding="7" width="100%" border="0">
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx();</td>
            <td valign="top" width="42%">Default constructor, constructs an instance of RegEx 
               without any valid expression.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx(<b>const</b> RegEx&amp; o);</td>
            <td valign="top" width="42%">Copy constructor, all the properties of parameter <i>o</i>
               are copied.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx(<b>const</b> <b>char</b>* c, <b>bool</b> icase 
               = <b>false</b>);</td>
            <td valign="top" width="42%">Constructs an instance of RegEx, setting the 
               expression to <i>c</i>, if <i>icase</i> is <i>true</i> then matching is 
               insensitive to case, otherwise it is sensitive to case. Throws <i>bad_expression</i>
               on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx(<b>const</b> std::string&amp; s, <b>bool</b> icase 
               = <b>false</b>);</td>
            <td valign="top" width="42%">Constructs an instance of RegEx, setting the 
               expression to <i>s</i>, if <i>icase</i> is <i>true</i> then matching is 
               insensitive to case, otherwise it is sensitive to case. Throws <i>bad_expression</i>
               on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b> RegEx&amp; 
               o);</td>
            <td valign="top" width="42%">Default assignment operator.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b> <b>char</b>* 
               p);</td>
            <td valign="top" width="42%">Assignment operator, equivalent to calling <i>SetExpression(p, 
                  false).</i> Throws <i>bad_expression</i> on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b> std::string&amp; 
               s);</td>
            <td valign="top" width="42%">Assignment operator, equivalent to calling <i>SetExpression(s, 
                  false).</i> Throws <i>bad_expression</i> on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> SetExpression(<b>constchar</b>* 
               p, <b>bool</b> icase = <b>false</b>);</td>
            <td valign="top" width="42%">Sets the current expression to <i>p</i>, if <i>icase</i>
               is <i>true</i> then matching is insensitive to case, otherwise it is sensitive 
               to case. Throws <i>bad_expression</i> on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> SetExpression(<b>const</b> 
               std::string&amp; s, <b>bool</b> icase = <b>false</b>);</td>
            <td valign="top" width="42%">Sets the current expression to <i>s</i>, if <i>icase</i>
               is <i>true</i> then matching is insensitive to case, otherwise it is sensitive 
               to case. Throws <i>bad_expression</i> on failure.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">std::string Expression()<b>const</b>;</td>
            <td valign="top" width="42%">Returns a copy of the current regular expression.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>bool</b> Match(<b>const</b> <b>char</b>* p, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Attempts to match the current expression against the 
               text <i>p</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. Returns <i>true</i> if the expression matches the whole of 
               the input string.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>bool</b> Match(<b>const</b> std::string&amp; s, 
               boost::match_flag_type flags = match_default) ;</td>
            <td valign="top" width="42%">Attempts to match the current expression against the 
               text <i>s</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. Returns <i>true</i> if the expression matches the whole of 
               the input string.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>bool</b> Search(<b>const</b> <b>char</b>* p, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Attempts to find a match for the current expression 
               somewhere in the text <i>p</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. Returns <i>true</i> if the match succeeds.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>bool</b> Search(<b>const</b> std::string&amp; s, 
               boost::match_flag_type flags = match_default) ;</td>
            <td valign="top" width="42%">Attempts to find a match for the current expression 
               somewhere in the text <i>s</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. Returns <i>true</i> if the match succeeds.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b>
               <b>char</b>* p, boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>p</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match found calls the call-back function <i>cb</i> 
               as: cb(*this);
               <p>If at any stage the call-back function returns false then the grep operation 
                  terminates, otherwise continues until no further matches are found. Returns the 
                  number of matches found.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b>
               std::string&amp; s, boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>s</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match found calls the call-back function <i>cb</i> 
               as: cb(*this);
               <p>If at any stage the call-back function returns false then the grep operation 
                  terminates, otherwise continues until no further matches are found. Returns the 
                  number of matches found.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; 
               v, <b>const</b> <b>char</b>* p, boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>p</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match pushes a copy of what matched onto <i>v</i>. 
               Returns the number of matches found.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; 
               v, <b>const</b> std::string&amp; s, boost::match_flag_type flags = 
               match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>s</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match pushes a copy of what matched onto <i>v</i>. 
               Returns the number of matches found.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned 
                  int</b>&gt;&amp; v, <b>const</b> <b>char</b>* p, boost::match_flag_type 
               flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>p</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match pushes the starting index of what matched 
               onto <i>v</i>. Returns the number of matches found.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned 
                  int</b>&gt;&amp; v, <b>const</b> std::string&amp; s, boost::match_flag_type 
               flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               text <i>s</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match pushes the starting index of what matched 
               onto <i>v</i>. Returns the number of matches found.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback 
               cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               files <i>files</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match calls the call-back function cb.&nbsp;
               <p>If the call-back returns false then the algorithm returns without considering 
                  further matches in the current file, or any further files.&nbsp;</p>
               <p>The parameter <i>files</i> can include wild card characters '*' and '?', if the 
                  parameter <i>recurse</i> is true then searches sub-directories for matching 
                  file names.&nbsp;</p>
               <p>Returns the total number of matches found.</p>
               <p>May throw an exception derived from std::runtime_error if file io fails.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback 
               cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Finds all matches of the current expression in the 
               files <i>files</i> using the match flags <i>flags</i> - see <a href="match_flag_type.html">
                  match flags</a>. For each match calls the call-back function cb.&nbsp;
               <p>If the call-back returns false then the algorithm returns without considering 
                  further matches in the current file, or any further files.&nbsp;</p>
               <p>The parameter <i>files</i> can include wild card characters '*' and '?', if the 
                  parameter <i>recurse</i> is true then searches sub-directories for matching 
                  file names.&nbsp;</p>
               <p>Returns the total number of matches found.</p>
               <p>May throw an exception derived from std::runtime_error if file io fails.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback 
               cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Searches <i>files</i> to find all those which contain 
               at least one match of the current expression using the match flags <i>flags</i> 
               - see <a href="match_flag_type.html">match flags</a>. For each matching file 
               calls the call-back function cb.&nbsp;
               <p>If the call-back returns false then the algorithm returns without considering 
                  any further files.&nbsp;</p>
               <p>The parameter <i>files</i> can include wild card characters '*' and '?', if the 
                  parameter <i>recurse</i> is true then searches sub-directories for matching 
                  file names.&nbsp;</p>
               <p>Returns the total number of files found.</p>
               <p>May throw an exception derived from std::runtime_error if file io fails.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback 
               cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, 
               boost::match_flag_type flags = match_default);</td>
            <td valign="top" width="42%">Searches <i>files</i> to find all those which contain 
               at least one match of the current expression using the match flags <i>flags</i> 
               - see <a href="match_flag_type.html">match flags</a>. For each matching file 
               calls the call-back function cb.&nbsp;
               <p>If the call-back returns false then the algorithm returns without considering 
                  any further files.&nbsp;</p>
               <p>The parameter <i>files</i> can include wild card characters '*' and '?', if the 
                  parameter <i>recurse</i> is true then searches sub-directories for matching 
                  file names.&nbsp;</p>
               <p>Returns the total number of files found.</p>
               <p>May throw an exception derived from std::runtime_error if file io fails.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">std::string Merge(<b>const</b> std::string&amp; in, <b>const</b>
               std::string&amp; fmt, <b>bool</b> copy = <b>true</b>, boost::match_flag_type 
               flags = match_default);</td>
            <td valign="top" width="42%">Performs a search and replace operation: searches 
               through the string <i>in</i> for all occurrences of the current expression, for 
               each occurrence replaces the match with the format string <i>fmt</i>. Uses <i>flags</i>
               to determine what gets matched, and how the format string should be treated. If <i>
                  copy</i> is true then all unmatched sections of input are copied unchanged 
               to output, if the flag <em>format_first_only</em> is set then only the first 
               occurance of the pattern found is replaced. Returns the new string. See <a href="format_syntax.html">
                  also format string syntax</a>, <a href="match_flag_type.html">match flags</a>
               and <a href="match_flag_type.html">format flags</a>.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">std::string Merge(<b>const</b> char* in, <b>const</b> 
               char* fmt, <b>bool</b> copy = <b>true</b>, boost::match_flag_type flags = 
               match_default);</td>
            <td valign="top" width="42%">Performs a search and replace operation: searches 
               through the string <i>in</i> for all occurrences of the current expression, for 
               each occurrence replaces the match with the format string <i>fmt</i>. Uses <i>flags</i>
               to determine what gets matched, and how the format string should be treated. If <i>
                  copy</i> is true then all unmatched sections of input are copied unchanged 
               to output, if the flag <em>format_first_only</em> is set then only the first 
               occurance of the pattern found is replaced. Returns the new string. See <a href="format_syntax.html">
                  also format string syntax</a>, <a href="match_flag_type.html">match flags</a>
               and <a href="match_flag_type.html">format flags</a>.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td>&nbsp;</td>
            <td valign="top"><b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp; v, 
               std::string&amp; s, boost::match_flag_type flags = match_default, <b>unsigned</b>
               max_count = ~0);</td>
            <td valign="top">Splits the input string and pushes each one onto the vector. If 
               the expression contains no marked sub-expressions, then one string is outputted 
               for each section of the input that does not match the expression. If the 
               expression does contain marked sub-expressions, then outputs one string for 
               each marked sub-expression each time a match occurs. Outputs no more than <i>max_count</i>
               strings. Before returning, deletes from the input string <i>s</i> all of the 
               input that has been processed (all of the string if <i>max_count</i> was not 
               reached). Returns the number of strings pushed onto the vector.</td>
            <td>&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Position(<b>int</b> i = 0)<b>const</b>;</td>
            <td valign="top" width="42%">Returns the position of what matched sub-expression <i>i</i>. 
               If <i>i = 0</i> then returns the position of the whole match. Returns 
               RegEx::npos if the supplied index is invalid, or if the specified 
               sub-expression did not participate in the match.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Length(<b>int</b> i = 0)<b>const</b>;</td>
            <td valign="top" width="42%">Returns the length of what matched sub-expression <i>i</i>. 
               If <i>i = 0</i> then returns the length of the whole match. Returns RegEx::npos 
               if the supplied index is invalid, or if the specified sub-expression did not 
               participate in the match.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td>&nbsp;</td>
            <td><strong>bool</strong> Matched(<strong>int</strong> i = 0)<strong>const</strong>;</td>
            <td>Returns true if sub-expression <em>i</em> was matched, false otherwise.</td>
            <td>&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned</b> <b>int</b> Line()<b>const</b>;</td>
            <td valign="top" width="42%">Returns the line on which the match occurred, indexes 
               start from 1 not zero, if no match occurred then returns RegEx::npos.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%"><b>unsigned int</b> Marks() const;</td>
            <td valign="top" width="42%">Returns the number of marked sub-expressions 
               contained in the expression. Note that this includes the whole match 
               (sub-expression zero), so the value returned is always &gt;= 1.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">std::string What(<b>int</b> i)<b>const</b>;</td>
            <td valign="top" width="42%">Returns a copy of what matched sub-expression <i>i</i>. 
               If <i>i = 0</i> then returns a copy of the whole match. Returns a null string 
               if the index is invalid or if the specified sub-expression did not participate 
               in a match.</td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
         <tr>
            <td valign="top" width="7%">&nbsp;</td>
            <td valign="top" width="43%">std::string <b>operator</b>[](<b>int</b> i)<b>const</b>
               ;</td>
            <td valign="top" width="42%">Returns <i>what(i);</i>
               <p>Can be used to simplify access to sub-expression matches, and make usage more 
                  perl-like.</p>
            </td>
            <td valign="top" width="7%">&nbsp;</td>
         </tr>
      </table>
      <br>
      <br>
      <p></p>
      <hr>
      <p>Revised 
         <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan --> 
         04 Feb 2004 
         <!--webbot bot="Timestamp" endspan i-checksum="39359" --></p>
      <p><i>© Copyright John Maddock&nbsp;1998- 
            <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y" startspan -->  2004<!--webbot bot="Timestamp" endspan i-checksum="39359" --></i></p>
      <P><I>Use, modification and distribution are subject to the Boost Software License, 
            Version 1.0. (See accompanying file <A href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</A>
            or copy at <A href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)</I></P>
   </body>
</html>
