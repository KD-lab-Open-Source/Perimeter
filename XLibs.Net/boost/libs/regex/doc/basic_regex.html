<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
   <head>
      <title>Boost.Regex: basic_regex</title>
      <meta name="generator" content="HTML Tidy, see www.w3.org">
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
      <link rel="stylesheet" type="text/css" href="../../../boost.css">
   </head>
   <body>
      <table id="Table1" cellspacing="1" cellpadding="1" width="100%" border="0">
         <tr>
            <td valign="top" width="300">
               <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
            </td>
            <td width="353">
               <h1 align="center">Boost.Regex</h1>
               <h2 align="center">basic_regex</h2>
            </td>
            <td width="50">
               <h3><a href="index.html"><img height="45" width="43" alt="Boost.Regex Index" src="uarrow.gif" border="0"></a></h3>
            </td>
         </tr>
      </table>
      <br>
      <br>
      <hr>
      <h3>Synopsis</h3>
      <pre>
#include &lt;<a href="../../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</pre>
      <p>The template class <em>basic_regex</em> encapsulates regular expression parsing 
         and compilation. The class takes three template parameters:</p>
      <p><b><i>charT</i></b>: determines the character type, i.e. either char or 
         wchar_t.</p>
      <p><b><i>traits</i></b>: determines the behavior of the character type, for 
         example which character class names are recognized. A default traits class is 
         provided: <a href="regex_traits.html">regex_traits&lt;charT&gt;</a>.</p>
      <p><b><i>Allocator</i></b>: the allocator class used to allocate memory by the 
         class.</p>
      <p>For ease of use there are two typedefs that define the two standard <i>basic_regex</i>
         instances, unless you want to use custom traits classes or allocators, you 
         won't need to use anything other than these:</p>
      <pre>
<b>namespace</b> boost{
<b>template</b> &lt;<b>class</b> charT, <b>class</b> traits = regex_traits&lt;charT&gt;, <b>class</b> Allocator = std::allocator&lt;charT&gt;  &gt;
<b>class</b> basic_regex;
<b>typedef</b> basic_regex&lt;<b>char</b>&gt; regex;
<b>typedef</b> basic_regex&lt;<b>wchar_t&gt;</b> wregex;
}
</pre>
      <p>The definition of <i>basic_regex</i> follows: it is based very closely on class 
         basic_string, and fulfils the requirements for a constant-container of <i>charT</i>.</p>
      <pre>
namespace boost{

template &lt;class charT,
          class traits = regex_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
class basic_regex
{
public:
   // types:
   typedef          charT                                value_type;
   typedef          implementation defined               const_iterator;
   typedef          const_iterator                       iterator;
   typedef typename Allocator::reference                 reference;
   typedef typename Allocator::const_reference           const_reference;
   typedef typename Allocator::difference_type           difference_type;
   typedef typename Allocator::size_type                 size_type;
   typedef          Allocator                            allocator_type;
   typedef          regex_constants::syntax_option_type  flag_type;
   typedef typename traits::locale_type                  locale_type;

   // constants:
   static const regex_constants::syntax_option_type normal = regex_constants::normal;
   static const regex_constants::syntax_option_type icase = regex_constants::icase;
   static const regex_constants::syntax_option_type nosubs = regex_constants::nosubs;
   static const regex_constants::syntax_option_type optimize = regex_constants::optimize;
   static const regex_constants::syntax_option_type collate = regex_constants::collate;
   static const regex_constants::syntax_option_type ECMAScript = normal;
   static const regex_constants::syntax_option_type JavaScript = normal;
   static const regex_constants::syntax_option_type JScript = normal;
   // these flags are optional, if the functionality is supported
   // then the flags shall take these names.
   static const regex_constants::syntax_option_type basic = regex_constants::basic;
   static const regex_constants::syntax_option_type extended = regex_constants::extended;
   static const regex_constants::syntax_option_type awk = regex_constants::awk;
   static const regex_constants::syntax_option_type grep = regex_constants::grep;
   static const regex_constants::syntax_option_type egrep = regex_constants::egrep;
   static const regex_constants::syntax_option_type sed = basic = regex_constants::sed;
   static const regex_constants::syntax_option_type perl = regex_constants::perl;

   // construct/copy/destroy:
   explicit <A href="#c1">basic_regex</A>(const Allocator&amp; a = Allocator());
   explicit <A href="#c2">basic_regex</A>(const charT* p, flag_type f = regex_constants::normal,
                        const Allocator&amp; a = Allocator());
   <A href="#c3">basic_regex</A>(const charT* p1, const charT* p2, flag_type f = regex_constants::normal,
               const Allocator&amp; a = Allocator());
   <A href="#c4">basic_regex</A>(const charT* p, size_type len, flag_type f,
               const Allocator&amp; a = Allocator());
   <A href="#c5">basic_regex</A>(const basic_regex&amp;);
   template &lt;class ST, class SA&gt;
   explicit <A href="#c6">basic_regex</A>(const basic_string&lt;charT, ST, SA&gt;&amp; p,
                        flag_type f = regex_constants::normal,
                        const Allocator&amp; a = Allocator());
   template &lt;class InputIterator&gt;
   <A href="#c7">basic_regex</A>(InputIterator first, inputIterator last,
               flag_type f = regex_constants::normal,
               const Allocator&amp; a = Allocator());

   ~basic_regex();
   basic_regex&amp; <A href="#o1">operator</A>=(const basic_regex&amp;);
   basic_regex&amp; <A href="#o2">operator</A>= (const charT* ptr); 
   template &lt;class ST, class SA&gt; 
   basic_regex&amp; <A href="#o3">operator</A>= (const basic_string&lt;charT, ST, SA&gt;&amp; p);
   // iterators: 
   const_iterator <A href="#m1">begin</A>() const; 
   const_iterator <A href="#m2">end</A>() const;
   // capacity: 
   size_type <A href="#m3">size</A>() const; 
   size_type <A href="#m4">max_size</A>() const; 
   bool <A href="#m5">empty</A>() const; 
   unsigned <A href="#m6">mark_count</A>()const; 
   //
   // modifiers: 
   basic_regex&amp; <A href="#a1">assign</A>(const basic_regex&amp; that); 
   basic_regex&amp; <A href="#a2">assign</A>(const charT* ptr, flag_type f = regex_constants::normal);
   basic_regex&amp; <A href="#a3">assign</A>(const charT* ptr, unsigned int len, flag_type f);
   template &lt;class string_traits, class A&gt;
   basic_regex&amp; <A href="#a4">assign</A>(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                       flag_type f = regex_constants::normal);
   template &lt;class InputIterator&gt;
   basic_regex&amp; <A href="#a5">assign</A>(InputIterator first, InputIterator last,
                       flag_type f = regex_constants::normal);

   // const operations:
   Allocator <A href="#m7">get_allocator</A>() const;
   flag_type <A href="#m8">flags</A>() const;
   basic_string&lt;charT&gt; <A href="#m9">str</A>() const;
   int <A href="#m10">compare</A>(basic_regex&amp;) const;
   // locale:
   locale_type <A href="#m11">imbue</A>(locale_type loc);
   locale_type <A href="#m12">getloc</A>() const;
   // swap
   void <A href="#m13">swap</A>(basic_regex&amp;) throw();
};

template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o4">operator</A> == (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o5">operator</A> != (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o7">operator</A> &lt; (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o8">operator</A> &lt;= (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o9">operator</A> &gt;= (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
template &lt;class charT, class traits, class Allocator&gt;
bool <A href="#o10">operator</A> &gt; (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);

template &lt;class charT, class io_traits, class re_traits, class Allocator&gt;
basic_ostream&lt;charT, io_traits&gt;&amp;
   <A href="#o11">operator</A> &lt;&lt; (basic_ostream&lt;charT, io_traits&gt;&amp; os,
                const basic_regex&lt;charT, re_traits, Allocator&gt;&amp; e);

template &lt;class charT, class traits, class Allocator&gt;
void <A href="#o12">swap</A>(basic_regex&lt;charT, traits, Allocator&gt;&amp; e1,
          basic_regex&lt;charT, traits, Allocator&gt;&amp; e2);

typedef basic_regex&lt;char&gt; regex;
typedef basic_regex&lt;wchar_t&gt; wregex;

} // namespace boost
</pre>
      <h3>Description</h3>
      <p>Class&nbsp;<em>basic_regex</em> has the following public member functions:</p>
      <h4>basic_regex constants</h4>
      <pre>
static const regex_constants::syntax_option_type normal = regex_constants::normal;
static const regex_constants::syntax_option_type icase = regex_constants::icase;
static const regex_constants::syntax_option_type nosubs = regex_constants::nosubs;
static const regex_constants::syntax_option_type optimize = regex_constants::optimize;
static const regex_constants::syntax_option_type collate = regex_constants::collate;
static const regex_constants::syntax_option_type ECMAScript = normal;
static const regex_constants::syntax_option_type JavaScript = normal;
static const regex_constants::syntax_option_type JScript = normal;
static const regex_constants::syntax_option_type basic = regex_constants::basic;
static const regex_constants::syntax_option_type extended = regex_constants::extended;
static const regex_constants::syntax_option_type awk = regex_constants::awk;
static const regex_constants::syntax_option_type grep = regex_constants::grep;
static const regex_constants::syntax_option_type egrep = regex_constants::egrep;
static const regex_constants::syntax_option_type sed = basic = regex_constants::sed;
static const regex_constants::syntax_option_type perl = regex_constants::perl;
</pre>
      <p>The static constant members are provided as synonyms for the constants declared 
         in namespace <code>boost::regex_constants</code>; for each constant of type <code><A href="syntax_option_type.html">
               syntax_option_type</A></code> declared in namespace <code>boost::regex_constants</code>
         then a constant with the same name, type and value is declared within the scope 
         of <code>basic_regex</code>.</p>
      <h4>basic_regex constructors</h4>
      <p>In all <code>basic_regex</code> constructors, a copy of the <code>Allocator</code>
         argument is used for any memory allocation performed by the constructor or 
         member functions during the lifetime of the object.</p>
      <pre>
basic_regex(const Allocator&amp; a = Allocator());
</pre>
      <P><b>Effects:</b> Constructs an object of class <code>basic_regex</code>. The 
         postconditions of this function are indicated in the table:</P>
      <div align="center">
         <center>
            <table id="Table2" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>true</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>0</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>basic_string&lt;charT&gt;()</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre> <A name=c2></A>basic_regex(const charT* p, flag_type f = regex_constants::normal, const Allocator&amp; a = Allocator());
 
</pre>
      <P><b>Requires:</b> <i>p</i> shall not be a null pointer.</P>
      <p><b>Throws:</b> <code>bad_expression</code> if <i>p</i> is not a valid regular 
         expression.</p>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code>; the 
         object's internal finite state machine is constructed from the regular 
         expression contained in the null-terminated string <i>p</i>, and interpreted 
         according to the <a href="syntax_option_type.html">option flags</a>&nbsp;specified 
         in <i>f</i>. The postconditions of this function are indicated in the table:</p>
      <div align="center">
         <center>
            <table id="Table3" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>char_traits&lt;charT&gt;::length(p)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>basic_string&lt;charT&gt;(p)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
 
</pre>
      <PRE><A name=c3></A>basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal, const Allocator&amp; a = Allocator());</PRE>
      <p><b>Requires:</b> <i>p1</i> and <i>p2</i> are not null pointers, <code>p1 &lt; p2</code>.</p>
      <p><b>Throws:</b> <code>bad_expression</code> if [p1,p2) is not a valid regular 
         expression.</p>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code>; the 
         object's internal finite state machine is constructed from the regular 
         expression contained in the sequence of characters [p1,p2), and interpreted 
         according the <a href="syntax_option_type.html">option flags</a> specified in <i>f</i>. 
         The postconditions of this function are indicated in the table:</p>
      <div align="center">
         <center>
            <table id="Table4" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>std::distance(p1,p2)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>basic_string&lt;charT&gt;(p1,p2)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
 
</pre>
      <pre><A name=c4></A>
basic_regex(const charT* p, size_type len, flag_type f, const Allocator&amp; a = Allocator());
</pre>
      <p><b>Requires:</b> <i>p</i> shall not be a null pointer, <code>len &lt; max_size()</code>.</p>
      <p><b>Throws:</b> <code>bad_expression</code> if <i>p</i> is not a valid regular 
         expression.</p>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code>; the 
         object's internal finite state machine is constructed from the regular 
         expression contained in the sequence of characters [p, p+len), and interpreted 
         according the <a href="syntax_option_type.html">option flags</a> specified in <i>f</i>. 
         The postconditions of this function are indicated in the table:</p>
      <div align="center">
         <center>
            <table id="Table5" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>len</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>basic_string&lt;charT&gt;(p, len)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
  
</pre>
      <pre><A name=c5></A>
basic_regex(const basic_regex&amp; e);
</pre>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code> as a 
         copy of the object <i>e</i>. The postconditions of this function are indicated 
         in the table:</p>
      <div align="center">
         <center>
            <table id="Table6" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>e.empty()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>e.size()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>e.str()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>e.flags()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>e.mark_count()</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
 
</pre>
      <pre>
template &lt;class ST, class SA&gt;
<A name=c6></A>
basic_regex(const basic_string&lt;charT, ST, SA&gt;&amp; s,
            flag_type f = regex_constants::normal, const Allocator&amp; a = Allocator());
</pre>
      <p><b>Throws:</b> <code>bad_expression</code> if <i>s</i> is not a valid regular 
         expression.</p>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code>; the 
         object's internal finite state machine is constructed from the regular 
         expression contained in the string <i>s</i>, and interpreted according to the <a href="syntax_option_type.html">
            option flags</a> specified in <i>f</i>. The postconditions of this function 
         are indicated in the table:</p>
      <div align="center">
         <center>
            <table id="Table7" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>s.size()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>s</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
 
</pre>
      <pre>
template &lt;class ForwardIterator&gt;
<A name=c7></A>
basic_regex(ForwardIterator first, ForwardIterator last,
            flag_type f = regex_constants::normal, const Allocator&amp; a = Allocator());
</pre>
      <p><b>Throws:</b> <code>bad_expression</code> if the sequence <i>[first, last)</i> 
         is not a valid regular expression.</p>
      <p><b>Effects:</b> Constructs an object of class <code>basic_regex</code>; the 
         object's internal finite state machine is constructed from the regular 
         expression contained in the sequence of characters [first, last), and 
         interpreted according to the <a href="syntax_option_type.html">option flags</a> 
         specified in <i>f</i>. The postconditions of this function are indicated in the 
         table:</p>
      <div align="center">
         <center>
            <table id="Table8" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>distance(first,last)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>basic_string&lt;charT&gt;(first,last)</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
  
</pre>
      <pre><A name=o1></A>
basic_regex&amp; operator=(const basic_regex&amp; e);
</pre>
      <p><b>Effects:</b> Returns the result of <code>assign(e.str(), e.flags())</code>.</p>
      <pre><A name=o2></A>
basic_regex&amp; operator=(const charT* ptr);
</pre>
      <p><b>Requires:</b> <i>p</i> shall not be a null pointer.</p>
      <p><b>Effects:</b> Returns the result of <code>assign(ptr)</code>.</p>
      <pre><A name=o3></A>
template &lt;class ST, class SA&gt;
basic_regex&amp; operator=(const basic_string&lt;charT, ST, SA&gt;&amp; p);
</pre>
      <p><b>Effects:</b> Returns the result of <code>assign(p)</code>.</p>
      <h4>basic_regex iterators</h4>
      <pre><A name=m1></A>
const_iterator begin() const;
</pre>
      <p><b>Effects:</b> Returns a starting iterator to a sequence of characters 
         representing the regular expression.</p>
      <pre><A name=m2></A>
const_iterator end() const;
</pre>
      <p><b>Effects:</b> Returns termination iterator to a sequence of characters 
         representing the regular expression.</p>
      <h4>basic_regex capacity</h4>
      <pre><A name=m3></A>
size_type size() const;
</pre>
      <p><b>Effects:</b> Returns the length of the sequence of characters representing 
         the regular expression.</p>
      <pre><A name=m4></A>
size_type max_size() const;
</pre>
      <p><b>Effects:</b> Returns the maximum length of the sequence of characters 
         representing the regular expression.</p>
      <pre><A name=m5></A>
bool empty() const;
</pre>
      <p><b>Effects:</b> Returns <b>true</b> if the object does not contain a valid 
         regular expression, otherwise <b>false</b>.</p>
      <pre><A name=m6></A>unsigned mark_count() const;
</pre>
      <p><b>Effects:</b> Returns the number of marked sub-expressions within the regular 
         expresion.</p>
      <h4>basic_regex assign</h4>
      <pre><A name=a1></A>
basic_regex&amp; assign(const basic_regex&amp; that);
</pre>
      <p><b>Effects:</b> Returns <code>assign(that.str(), that.flags())</code>.</p>
      <pre><A name=a2></A>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::normal);
</pre>
      <p><b>Effects:</b> Returns <code>assign(string_type(ptr), f)</code>.</p>
      <PRE><A name=a3></A><A name=a3></A>basic_regex&amp; assign(const charT* ptr, unsigned int len, flag_type f);</PRE>
      <P><B>Effects:</B> Returns <CODE>assign(string_type(ptr, len), f)</CODE>.</P>
      <PRE><A name=a4></A>template &lt;class string_traits, class A&gt;
<A name=a6></A>basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                    flag_type f = regex_constants::normal);
</PRE>
      <p><b>Throws:</b> <code>bad_expression</code> if <i>s</i> is not a valid regular 
         expression.</p>
      <p><b>Returns:</b> <code>*this</code>.</p>
      <p><b>Effects:</b> Assigns the regular expression contained in the string <i>s</i>, 
         interpreted according the <a href="syntax_option_type.html">option flags</a> specified 
         in <i>f</i>. The postconditions of this function are indicated in the table:</p>
      <div align="center">
         <center>
            <table id="Table9" cellspacing="1" cellpadding="7" width="624" border="1">
               <tbody>
                  <tr>
                     <td valign="top" width="50%">
                        <p><b>Element</b></p>
                     </td>
                     <td valign="top" width="50%">
                        <p><b>Value</b></p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>empty()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>false</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>size()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>s.size()</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>str()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>s</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>flags()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>f</p>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" width="50%">
                        <p>mark_count()</p>
                     </td>
                     <td valign="top" width="50%">
                        <p>The number of marked sub-expressions within the expression.</p>
                     </td>
                  </tr>
               </tbody>
            </table>
         </center>
      </div>
      <pre>
 
</pre>
      <pre><A name=a5></A>template &lt;class InputIterator&gt;
basic_regex&amp; assign(InputIterator first, InputIterator last,
                    flag_type f = regex_constants::normal);
</pre>
      <p><b>Requires:</b> The type InputIterator corresponds to the Input Iterator 
         requirements (24.1.1).</p>
      <p><b>Effects:</b> Returns <code>assign(string_type(first, last), f)</code>.</p>
      <h4>basic_regex constant operations</h4>
      <pre><A name=m7></A>Allocator get_allocator() const;
</pre>
      <p><b>Effects:</b> Returns a copy of the Allocator that was passed to the object's 
         constructor.</p>
      <pre><A name=m8></A>flag_type flags() const;
</pre>
      <p><b>Effects:</b> Returns a copy of the regular expression syntax flags that were 
         passed to the object's constructor, or the last call to <code>assign.</code></p>
      <pre><A name=m9></A>basic_string&lt;charT&gt; str() const;
</pre>
      <p><b>Effects:</b> Returns a copy of the character sequence passed to the object's 
         constructor, or the last call to <code>assign.</code></p>
      <pre><A name=m10></A>int compare(basic_regex&amp; e)const;
</pre>
      <p><b>Effects:</b> If <code>flags() == e.flags()</code> then returns <code>str().compare(e.str())</code>, 
         otherwise returns <code>flags() - e.flags()</code>.</p>
      <h4>basic_regex locale</h4>
      <pre><A name=m11></A>locale_type imbue(locale_type l);
</pre>
      <p><b>Effects:</b> Returns the result of <code>traits_inst.imbue(l)</code> where <code>
            traits_inst</code> is a (default initialized) instance of the template 
         parameter <code>traits</code> stored within the object. Calls to imbue 
         invalidate any currently contained regular expression.</p>
      <p><b>Postcondition:</b> <code>empty() == true</code>.</p>
      <pre><A name=m12></A>
locale_type getloc() const;
</pre>
      <p><b>Effects:</b> Returns the result of <code>traits_inst.getloc()</code> where <code>
            traits_inst</code> is a (default initialized) instance of the template 
         parameter <code>traits</code> stored within the object.</p>
      <h4>basic_regex swap</h4>
      <pre><A name=m13></A>
void swap(basic_regex&amp; e) throw();
</pre>
      <p><b>Effects:</b> Swaps the contents of the two regular expressions.</p>
      <p><b>Postcondition:</b> <code>*this</code> contains the characters that were in <i>e</i>,
         <i>e</i> contains the regular expression that was in <code>*this</code>.</p>
      <p><b>Complexity:</b> constant time.</p>
      <h4>basic_regex non-member functions</h4>
      <h5>basic_regex non-member comparison operators&nbsp;</h5>
      <P>Comparisons between basic_regex objects are provided on an experimental basis: 
         please note that these are likely to be removed from the standard library 
         proposal, so use with care if you are writing portable code.</P>
      <pre><A name=o4></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator == (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) == 0</code>.</p>
      <pre><A name=o5></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator != (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) != 0</code>.</p>
      <pre><A name=o7></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator &lt; (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) &lt; 0</code>.</p>
      <pre><A name=o8></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator &lt;= (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) &lt;= 0</code>.</p>
      <pre><A name=o9></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator &gt;= (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) &gt;= 0</code>.</p>
      <pre><A name=o10></A>
template &lt;class charT, class traits, class Allocator&gt;
bool operator &gt; (const basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> Returns <code>lhs.compare(rhs) &gt; 0</code>.</p>
      <h5>basic_regex inserter.</h5>
      <P>The basic_regex stream inserter is provided on an experimental basis, and 
         outputs the textual representation of the expression to the stream:</P>
      <pre><A name=o11></A>
template &lt;class charT, class io_traits, class re_traits, class Allocator&gt;
basic_ostream&lt;charT, io_traits&gt;&amp;
   operator &lt;&lt; (basic_ostream&lt;charT, io_traits&gt;&amp; os
                const basic_regex&lt;charT, re_traits, Allocator&gt;&amp; e);
</pre>
      <p><b>Effects:</b> Returns (os &lt;&lt; e.str()).</p>
      <h5>basic_regex non-member swap</h5>
      <pre><A name=o12></A>
template &lt;class charT, class traits, class Allocator&gt;
void swap(basic_regex&lt;charT, traits, Allocator&gt;&amp; lhs,
          basic_regex&lt;charT, traits, Allocator&gt;&amp; rhs);
</pre>
      <p><b>Effects:</b> calls <code>lhs.swap(rhs)</code>.</p>
      <hr>
      <p>Revised 
         <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan --> 
         24 Oct 2003 
         <!--webbot bot="Timestamp" endspan i-checksum="39359" --></p>
      <p><i>© Copyright John Maddock&nbsp;1998- 
            <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y" startspan --> 
            2003<!--webbot bot="Timestamp" endspan i-checksum="39359" --></i></p>
      <P><I>Use, modification and distribution are subject to the Boost Software License, 
            Version 1.0. (See accompanying file <A href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</A>
            or copy at <A href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)</I></P>
   </body>
</html>
